package android.os;

import java.util.LinkedList;

import android.app.ActivityManagerNative;
import android.util.Log;

/**
 * Model of Android's MessageQueue. A {@link LinkedList} of messages are kept
 * instead of a pool of messages. Idlehandlers have been removed. Further
 * instead of polling for user in the next() method when there are no current
 * messages to process, the thread does not block and calls native method
 * processScriptAction to generate new events. The original MessageQueue Queued
 * the messages in a priorityQueue by time. The time is not currently used in
 * this message queue.
 * 
 * TODO Add time support - but is this helpful as our Android implementation
 * does not use this currently
 */
public class MessageQueue {
  private final static String TAG = MessageQueue.class.getSimpleName();

  /** Actual MessageQueue */
  private LinkedList<Message> mMessages = new LinkedList<Message>();

  private boolean mQuiting;
  boolean mQuitAllowed = true;

  private static int messageCount = 0;

  //the current event & path being handled
  protected static int currentEvent = 0;
  protected static String currentPath = "0";

  public MessageQueue() {
    init0();
  }

  private native void init0();

  /**
   * Return the next message in the message queue. If the queue is empty new
   * events are generated by calling the native method processScriptAction to
   * generate new events.
   * 
   * @return The next {@link Message} object to handle.
   */
  final protected Message next() {
    Message m = null;

    for (;;) {

      if ((m = nextNonBlocked()) != null) {
        // if there is a message in the queue return it
        return m;

      } else {
        // if there is a script action, process it.
        String action = getNextScriptAction(messageCount);
        processAction(action);
      }
    }
  }

  public native String getNextScriptAction(int count);

  public void processAction(String action) {

    if (action == null) {
      // there are no actions in the script

      if (!hasOtherRunningThreads()) {
        // there are no more running threads

        Log.i(TAG, "Enqueing stop Message. MSG #:" + messageCount);
        enqueueStopMessage();

      } else {

        // there are still other running threads, wait for them to finish. When they
        // put msg in queue they will notify the main thread, otherwise when they 
        // terminate the main thread will be waked.

        try {
          Thread.sleep(100);
        } catch (InterruptedException e) {
        }

      }// end, we will notify the main thread.

    } else {
      // get ready a msg will be processed now

      //      // event will be rescheduled
      //      currentEvent = m.getEventID();
      //      currentPath = m.getPathID();

      messageCount = messageCount + 1;

    }

  }

  private void enqueueStopMessage() {
    ActivityManagerNative.getDefault().stopApplication();
    mQuiting = true;
    enqueueMessage(new Message());
  }

  private native boolean hasOtherRunningThreads();

  /**
   * Without blocking returns the next message in the queue or null if the queue
   * is empty.
   * 
   * @return
   */
  final synchronized Message nextNonBlocked() {
    if (mMessages.isEmpty()) {
      return null;
    } else {

      Message m = mMessages.removeFirst();
      currentEvent = m.getEventID();
      currentPath = m.getPathID();

      Log.i(TAG, "*************** MSG #: " + messageCount + " eventID:" + currentEvent + " pathID:"
          + currentPath);

      messageCount++;
      return m;
    }
  }

  final synchronized boolean enqueueMessage(Message msg) {
    int event = getCurrentEvent(Thread.currentThread());
    String path = getCurrentPath(Thread.currentThread());

    msg.setEventID(event);
    msg.setPathID(path);

    boolean enq = mMessages.add(msg);
    return enq;
  }

  private native String getCurrentPath(Thread thread);

  private native int getCurrentEvent(Thread thread);

  final synchronized boolean enqueueMessage(Message msg, long when) {
    String path = getCurrentPath(Thread.currentThread());
    int event = getCurrentEvent(Thread.currentThread());
    
    msg.setEventID(event);
    msg.setPathID(path);

    boolean enq = mMessages.add(msg);
    return enq;
  }

  final void removeMessages(Handler h, Runnable r, Object object) {
    // not necessary to implement
    throw new UnsupportedOperationException();
  }

  final void removeCallbacksAndMessages(Handler h, Object object) {
    // not necessary to implement
    throw new UnsupportedOperationException();

  }

  public int getSize() {
    return mMessages.size();
  }

  public Message getMessage(int i) {
    return mMessages.get(i);
  }

  public void enqueueStop() {
    enqueueMessage(new Message());
  }
}