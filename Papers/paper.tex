% paper.tex
% sample ACM SIG Proceedings document using LaTeX2e
% Author: Heila van der Merwe
% based upon LaTeX2.09 Guidelines, 9 June 1996
% Revisions:  10 July 2012

%


\documentclass{acm_proc_article-sp}
\usepackage{graphicx}
\begin{document}


\title{Verifying Android Applications using Java PathFinder}

\numberofauthors{3}

\author{%
\alignauthor  Brink van der Merwe\\
 \affaddr{Dept. of Computer Science}\\
       \affaddr{University of Stellenbosch}\\
       \affaddr{Private Bag X1 Matieland}\\
       \affaddr{South Africa, 7602}
       \email{abvdm@gmail.com}
\alignauthor Heila van der Merwe\\
       \affaddr{Dept. of Computer Science}\\
       \affaddr{University of Stellenbosch}\\
       \affaddr{Private Bag X1 Matieland}\\
       \affaddr{South Africa, 7602}
       \email{heilamvdm@gmail.com}
\alignauthor  Willem Visser\\
 \affaddr{Dept. of Computer Science}\\
       \affaddr{University of Stellenbosch}\\
       \affaddr{Private Bag X1 Matieland}\\
       \affaddr{South Africa, 7602}
       \email{willem@gmail.com}
}


\maketitle

\begin{abstract}

\end{abstract}

% A category with the (minimum) three required fields
\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

\terms{VERIFICATION}

\keywords{Java PathFinder, JPF, Android, Verification} % NOT required for Proceedings

\section{Introduction}
%The current trend in software development is mobile application development.

%At Google I/O 2012 Android claimed to have approximately 600
%thousand applications on the market with a total of 20 billion application downloads. They continue to note that this number is growing by
%one billion per month.

%Although Android mobile applications and Java desktop applications both use the Java language, they are developed for completely different
%platforms.  and both contain many similar errors and defects. These defects include faults such as concurrency issues and run-time
%exceptions. 
 %        are  compared to

%Software testing is a complex and time consuming process.   

Android applications and Java desktop applications are designed for completely different computing platforms. They are both however, built on an implementation of the 
Java programming language. As a consequence, Android applications contain many of the same defects as Java applications. These defects include but is not limited to concurrency
issues and runtime exceptions. It follows that it must be possible to adapt existing testing frameworks for Java applications to verify Android applications.

The problem is that Android applications face the following obstacles when it comes to application testing:
\begin{description}
 \item [Event driven architecture]. Android application flow is driven by events. This event input must be simulated which is especially difficult due to the many types of
sensory and system inputs that must be supported. 

 \item [The device challenge]. 
 Mobile applications are created to run on ARM devices/ emulators. Additionally the physical devices are
not designed with testing in mind. Alternative ways have to be devised to automatically simulate input to the application.
- java version


 \item [Operating system variety]. It is impossible to test an application on all the different operating system versions.
\end{description}

Due to these challenges and the rapid pace at which applications are developed and released~\cite{}, mobile application testing becomes too expensive in
terms of time and money. This results in many mobile applications being unstable and unreliable.

Manual testing is not the solution to the problem as it is very expensive, time consuming and does not detect enough errors in
Android applications. That is why only automatic testing frameworks are discussed below.

There are currently two ways to automatically test Android applications: on the device/emulator or on a computer.

The most common way is to test an application is the on a physical device/emulator. Examples of such projects include 
the Android testing framework~\cite{AndroidTesting}, MonkeyRunner~\cite{AndroidTesting} and Robotium~\cite{Robotium}. 
These projects depend on Android's built-in JUnit framework and InstrumentationTestRunner as the test case runner~\cite{AndroidTesting}.Other
projects use alternative ways to automatically generate input by manipulating the accessibility technologies 
or the software keyboard~\cite{AccessibilityTech, KeyboardModel}. Mockito or Android Mock a user to  mock out the Android SDK. While this is a valid approach, we have found that without Robolectric, the level of mocking needed to test an 
Android app quickly yields tests that are essentially reverse implementations of the application code.
 
The advantage of running the application on the emulator is that the application runs on actual android operating system. The disadvantage is, as mentioned before,
Android applications are driven by user and system events. So the input has to be modeled which is not so easy. It is slow to run the tests and each test 
sequence has to be defined and executed one by one. 
 
The other approach is to test an Android application on the computer. There are different ways of implementing such a framework. Android lint~\cite{} for example makes 
use of static analysis to identify common errors in applications. Robolectric~\cite{} create mocks of classes that allows an application to be Unit tested on the JVM.

% what are we going to do and why (WHAT ARE ADVANTAGES)
This paper describes jpf-android, an extension to Java PathFinder~\cite{JPFDocs} which is a Java application model checker framework. jpf-android will allow the automatic
verification of Android Applications on the standard Java jvm. 

The first section of the paper provides an overview of Android and Java Pathfinder and how JPF can be used to test Android applications.
The next section describes the design and development of the jpf-android tool followed by an simple example to show how the tool works. The
paper will conclude by discussing the effectiveness and usefulness of the tool.

\section{Background}
\subsection{The Android architecture}
Android is an open source software stack for mobile devices such as smartphones and tablets with an advanced RISC Machine (ARM)
architecture.

It consists of:
    the Android operating system built on top of a modified Linux kernel,
    the application framework - set of libraries api
    an application development toolkit assisting developers to create applications for the platform.

    
An application runs on framework using api libs to communicate.
system process threading

%\begin{figure}[h!]
% \centering
% \includegraphics[width=\pagewidth]{../../M-Projek/heila/research_proposal/02-AndroidStack.png}
 % 5502982451_1f78830c9e.jpg: 500x270 pixel, 96dpi, 13.23x7.14 cm, bb=0 0 375 203
%\end{figure}

each application runs in own process
1 thread called the looper
handler message queue structure
2 types of input


%\begin{figure}[h!]
% \centering
% \includegraphics[width=\pagewidth]{../../M-Projek/heila/research_proposal/5502982451_1f78830c9e.jpg}
 % 5502982451_1f78830c9e.jpg: 500x270 pixel, 96dpi, 13.23x7.14 cm, bb=0 0 375 203
%\end{figure}

% why cant we just run android applications they are written in java?
Specific java version without swing etc
native code - has to be modelled


\subsection{Java PathFinder}
JPF is a powerful software model checker used to test automatically whether the system under test (SUT) meets a given specification.
Java applications~\cite{}. It consists of a custom Java virtual machine implementation that executes the compiled java byte-code of the
system under test(SUT).


JPF models the Java API libraries to allow... 
-how does it work?
-modelled java libs
-custom vm executing java bytecode
-controlled environment executing all execution paths
-listeners for certain property violations 

Furthermore, JPF's design encourages developers to create extensions to the framework. It provides that key mechanisms:
to model java libraries,
model native method calls (MJI),
track bytecode execusion and listen for property violations


Currently there exists many extensions including a symbolic execution extension (jpf-symbc), data race detector (jpf-racefinder) and a
abstract window toolkit (AWT) extension (jpf-awt).

One of the advantages of extending JPF is that it has been thoroughly tested and already works for Java applications. So as soon as the the
Android applications can run on JPF, common errors and defects can be detected. It provides an simple way to model classes.

\subsection{Applying JPF to Android applications}
Android applications are written in a custom Java implementation Apache Harmony.

Dalvik, the virtual machine used in Google's Android platform, uses a subset of Harmony for the core of its Class Library.[15] However,
Dalvik does not align to Java SE nor Java ME Class Library profiles (for example J2ME classes, AWT and Swing are not supported). Instead it
uses its own library,[16] built on a subset of Harmony.

-model the android framework so that android applications can run on the java JVM
-on it can be run on the java jvm we can run it on jpfâ€™s java jvm

- testing with object maps
- advantage above capture and replay is that all event sequences are executed


%what do I want to detect?
The objective of this project is to create a JPF extension based on JPF-AWT's scripting mechanism that will:
\begin{itemize}
 \item model the Android framework libraries using Java SE. Android applications are built on a framework written in Apache Harmony's Java
implementation. This framework will basically be simplified and closed down to allow the Android application to execute in a controlled
environment of JPF on a computer.

 \item model user and system input to the application. Android applications are event driven. We need to create a user model to simulate
input events for the application, similar to a driver. 

 \item use these models to automatically detect property violations such as deadlocks,race conditions and run-time exceptions in Android
applications.

\end{itemize}
\newpage
\section{Development}

% what are the issues of modelling the framework?
Modeling the Android framework is quite a complex task. The main problems being:
\begin{itemize}
 \item android.jar libs
\item we need a driver 
 \item size of android framework - what to model
  - we don't necessarily want to have to run android applications exactly as they are run, then gets to complication to test all application
  paths.
   - the more is modelled the more has to be re-modelled if something changes
   - if too little is modelled, then support to little functionality

\item native code and the fact that it is run in different thread - but if not native cannot be back tracked





\end{itemize}


2 important parts to model:
- processes we donâ€™t need ipc on computer everything runs in one process and we do not need this for testing
- binder ipc communication between components very import part see application as a whole
- gui\& system events drives applciation
- application framework


% description of the model:
1 process
1 main thread
1 application
direct communication instead of binder
no gui drawing

\subsection{The model}
- how is an application structured
--activitythread
--messagequeue + handler structure
--window structure


script input
- what is the purpose of the script
-- input to program
-- vars added
-- later check added

- what can the script handle
- GUI and external events
-- depth first
-- non-determinism

- what can the script not handle
-- specific activity event structure
-- progressive disclosure

how and where is the script events handled
- messagequeue processScriptAction
- generates event sequences uses backtrack to do depth first search trough all possible sequences
\newpage
\section{Example}
% example showing the detection of a null pointer exception in certain case





\section{Discussion}
%discussion showing how the tool is successful and the advantages of the tool




\section{Conclusion}


limitations
- only 1 application
- no android native code can be handled



\section{Acknowledgements}

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{paper}  % sigproc.bib is the name of the Bibliography in this case
% 
\end{document}
